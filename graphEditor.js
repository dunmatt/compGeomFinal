// Generated by CoffeeScript 1.4.0
(function() {
  var addEdge, addEdgeMode, click, compareEvents, deleteMode, deleteModeClass, deleteVertex, drag, dragended, dragmove, dragstarted, drawChildren, drawEdges, drawSlabs, drawTree, drawVertices, edgeModeClass, edges, editMode, editModeClass, height, keyAlreadyDown, keydown, keyup, lastTreeEnd, lines, mousemove, radius, rightmostPointLeftOfMouse, slabLines, svg, tentativeEdge, toggleEditMode, tree, treeGroup, vertices,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.points = [];

  lines = [];

  tree = null;

  keyAlreadyDown = false;

  editMode = true;

  addEdgeMode = false;

  deleteMode = false;

  tentativeEdge = null;

  lastTreeEnd = null;

  radius = 5;

  height = 400;

  editModeClass = "editMode";

  edgeModeClass = "edgeMode";

  deleteModeClass = "deleteMode";

  svg = d3.select("body").append("svg").attr("width", 700).attr("height", height).attr("class", editModeClass);

  slabLines = svg.append("svg:g").selectAll("line");

  treeGroup = svg.append("svg:g");

  edges = svg.append("svg:g").selectAll("line");

  vertices = svg.append("svg:g").selectAll("circle");

  addEdge = function(v, e) {
    return v.edges[v.edges.length] = e;
  };

  window.deleteAllVertices = function() {
    lines.length = 0;
    return points.length = 0;
  };

  deleteVertex = function(v) {
    var l, p, points;
    lines = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        l = lines[_i];
        if (__indexOf.call(v.edges, l) < 0) {
          _results.push(l);
        }
      }
      return _results;
    })();
    return points = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        p = points[_i];
        if (p !== v) {
          _results.push(p);
        }
      }
      return _results;
    })();
  };

  rightmostPointLeftOfMouse = function() {
    var best;
    best = {
      x: 0,
      y: height / 2
    };
    points.forEach(function(p) {
      if (p.x < d3.event.x && p.x > best.x) {
        return best = p;
      }
    });
    return best;
  };

  keyup = function() {
    if (editMode) {
      keyAlreadyDown = false;
      addEdgeMode = false;
      deleteMode = false;
      svg.classed(edgeModeClass, false);
      return svg.classed(deleteModeClass, false);
    }
  };

  keydown = function() {
    var r, _i, _len, _ref;
    if (d3.event.keyCode === 65) {
      _ref = tree.roots;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        alert("" + r.time + ": " + r.root);
      }
    }
    if (editMode) {
      d3.event.preventDefault();
      if (keyAlreadyDown) {
        return;
      }
      keyAlreadyDown = true;
      switch (d3.event.keyCode) {
        case 16:
          addEdgeMode = true;
          return svg.classed(edgeModeClass, true);
        case 17:
          deleteMode = true;
          return svg.classed(deleteModeClass, true);
      }
    }
  };

  mousemove = function() {
    if (!editMode) {
      return reset();
    }
  };

  dragstarted = function(d) {
    var s;
    if (editMode) {
      d3.event.sourceEvent.stopPropagation;
      s = d3.select(this).classed("dragging", true);
      if (addEdgeMode) {
        return tentativeEdge = {
          origin: s,
          line: svg.append("line").attr("x1", s.attr("cx")).attr("y1", s.attr("cy")).attr("x2", s.attr("cx")).attr("y2", s.attr("cy"))
        };
      }
    }
  };

  dragmove = function(d) {
    if (editMode) {
      if (tentativeEdge != null) {
        return tentativeEdge.line.attr("x2", d3.event.x).attr("y2", d3.event.y);
      } else {
        d3.select(this).datum().x = d3.event.x;
        d3.select(this).datum().y = d3.event.y;
        return reset();
      }
    }
  };

  window.addEdgeBothWays = function(a, b) {
    lines[lines.length] = {
      a: a,
      b: b
    };
    addEdge(a, lines[lines.length - 1]);
    return addEdge(b, lines[lines.length - 1]);
  };

  dragended = function(d) {
    var m;
    if (editMode) {
      d3.select(this).classed("dragging", false);
      if (tentativeEdge != null) {
        m = d3.mouse(this);
        points.forEach(function(t) {
          var x, y;
          x = t.x - m[0];
          y = t.y - m[1];
          if (Math.sqrt(x * x + y * y) < radius) {
            return addEdgeBothWays(tentativeEdge.origin.datum(), t);
          }
        });
        tentativeEdge.line.remove();
        tentativeEdge = null;
      }
      return reset();
    }
  };

  drag = d3.behavior.drag().on("drag", dragmove).on("dragstart", dragstarted).on("dragend", dragended);

  window.addPt = function(x, y) {
    return points[points.length] = {
      x: x,
      y: y,
      edges: []
    };
  };

  click = function() {
    var m;
    if (editMode) {
      if (d3.event.defaultPrevented) {
        return;
      }
      if (deleteMode) {
        m = d3.mouse(this);
        points.forEach(function(t) {
          var x, y;
          x = t.x - m[0];
          y = t.y - m[1];
          if (Math.sqrt(x * x + y * y) < radius) {
            return deleteVertex(t);
          }
        });
      } else {
        addPt(d3.mouse(this)[0], d3.mouse(this)[1]);
      }
      return reset();
    }
  };

  window.reset = function() {
    if (!editMode) {
      drawTree();
    }
    drawSlabs();
    drawEdges();
    return drawVertices();
  };

  drawTree = function() {
    var cx, cy, root, ry, step, t;
    svg.selectAll(".rbtLink").remove();
    t = d3.event.x - 10;
    root = tree.getRoot(t);
    if (root) {
      step = t / (root.height());
      ry = height / 2;
      cx = Math.max(step, root.line.a.x + .1 * (root.line.b.x - root.line.a.x));
      cy = root.line.yCoordAt(cx);
      return drawChildren(root, {
        x: cx,
        y: cy
      }, t, root.height());
    }
  };

  drawChildren = function(origin, start, endX, treeHeight, depth) {
    var cx, cy, gx, hx, step;
    if (depth == null) {
      depth = 1;
    }
    step = (endX - start.x) / (treeHeight - depth);
    if (origin.left) {
      cx = Math.max(start.x + step, origin.left.line.a.x + .1 * (origin.left.line.b.x - origin.left.line.a.x));
      cy = origin.left.line.yCoordAt(cx);
      gx = start.x + ((cx - start.x) / 4);
      hx = start.x + ((cx - start.x) * 3 / 4);
      treeGroup.append("path").attr("d", "M" + start.x + " " + start.y + "C" + hx + " " + start.y + " " + gx + " " + cy + " " + cx + " " + cy).attr("class", "rbtLink");
      drawChildren(origin.left, {
        x: cx,
        y: cy
      }, endX, treeHeight, depth + 1);
    }
    if (origin.right) {
      cx = Math.max(start.x + step, origin.right.line.a.x + .1 * (origin.right.line.b.x - origin.right.line.a.x));
      cy = origin.right.line.yCoordAt(cx);
      gx = start.x + ((cx - start.x) / 4);
      hx = start.x + ((cx - start.x) * 3 / 4);
      treeGroup.append("path").attr("d", "M" + start.x + " " + start.y + "C" + hx + " " + start.y + " " + gx + " " + cy + " " + cx + " " + cy).attr("class", "rbtLink");
      return drawChildren(origin.right, {
        x: cx,
        y: cy
      }, endX, treeHeight, depth + 1);
    }
  };

  drawSlabs = function() {
    slabLines = slabLines.data(points).attr("x1", function(v) {
      return v.x;
    }).attr("x2", function(v) {
      return v.x;
    });
    slabLines.enter().append("line").attr("x1", function(v) {
      return v.x;
    }).attr("x2", function(v) {
      return v.x;
    }).attr("y1", function(v) {
      return 0;
    }).attr("y2", function(v) {
      return height;
    }).attr("class", "slabWall");
    return slabLines.exit().remove();
  };

  drawEdges = function() {
    edges = edges.data(lines).attr("x1", function(l) {
      return l.a.x;
    }).attr("y1", function(l) {
      return l.a.y;
    }).attr("x2", function(l) {
      return l.b.x;
    }).attr("y2", function(l) {
      return l.b.y;
    });
    edges.enter().append("line").attr("x1", function(l) {
      return l.a.x;
    }).attr("y1", function(l) {
      return l.a.y;
    }).attr("x2", function(l) {
      return l.b.x;
    }).attr("y2", function(l) {
      return l.b.y;
    });
    return edges.exit().remove();
  };

  drawVertices = function() {
    vertices = vertices.data(points).attr("cx", function(v) {
      return v.x;
    }).attr("cy", function(v) {
      return v.y;
    });
    vertices.enter().append("circle").attr("cx", function(v) {
      return v.x;
    }).attr("cy", function(v) {
      return v.y;
    }).attr("r", radius).attr("class", "dot").call(drag);
    return vertices.exit().remove();
  };

  compareEvents = function(a, b) {
    if (a[0] === b[0] && a[2] === b[2]) {
      if (a[1]) {
        return -1;
      } else {
        return 1;
      }
    } else if (a[0] === b[0]) {
      if (!a[1]) {
        return -1;
      } else {
        return 1;
      }
    } else {
      if (a[0] < b[0]) {
        return -1;
      } else {
        return 1;
      }
    }
  };

  toggleEditMode = function() {
    var events, seg, segments;
    editMode = !svg.classed(editModeClass);
    svg.classed(editModeClass, editMode);
    tree = new RedBlackTree();
    svg.selectAll(".rbtLink").remove();
    if (!editMode) {
      segments = lines.map(function(l) {
        return new LineSegment(l.a, l.b);
      });
      events = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = segments.length; _i < _len; _i++) {
          seg = segments[_i];
          _results.push([seg.a.x, true, seg]);
        }
        return _results;
      })()).concat((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = segments.length; _i < _len; _i++) {
          seg = segments[_i];
          _results.push([seg.b.x, false, seg]);
        }
        return _results;
      })());
      events.sort(compareEvents);
      return events.forEach(function(e) {
        if (e[1]) {
          return tree.insert(e[0], e[2]);
        } else {
          return tree["delete"](e[0], e[2]);
        }
      });
    }
  };

  svg.on("click", click).on("mousemove", mousemove);

  d3.select(window).on("keyup", keyup).on("keydown", keydown).on("mousedown", function() {
    return d3.event.preventDefault();
  });

  d3.select("body").append("button").text("Toggle Query Mode").on("click", toggleEditMode);

}).call(this);
