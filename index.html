<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>Comp 163 Final Project</title>
  <link rel="stylesheet" type="text/css" href="style.css"/>
  <script type="text/javascript" src="d3.v3.min.js" charset="utf-8"></script>
</head>
<body>
  <h1>Planar Point Location</h1>
  <script type="text/javascript" src="redblack.js" charset="utf-8"></script>
  <script type="text/javascript" src="graphEditor.js" charset="utf-8"></script>
  <script type="text/javascript" src="lineSegment.js" charset="utf-8"></script>

  <h3>Directions:</h3>
  <ol>
  	<li>Click to place points, drag to move points around</li>
  	<li>Shift + Drag to create edges (planar graphs only)</li>
  	<li>Ctrl + Click to delete points (and their edges)</li>
  	<li>When you're happy with your graph click "Toggle Query Mode" and move the mouse (which represents a query point) around.</li>
  	<li>Press 'a' in Query Mode for a debugging dump of the fully persistent red black tree.</li>
  </ol>
  <h3>Ok, so that's great, but what am I looking at?</h3>
  <p>Planar point location is the problem of quickly determining what polygon each of a series of query points is in.  Because there are potentially many query points we want to preprocess the graph to ensure fast querying with minimal memory overhead.  The algorithm here, (first presented by Sarnak and Tarjan in Planar Point Location Using Persistent Search Trees) is to store the edges of the planar graph into a partially persistent binary search tree.  Because it is a BST, queries and updates can be done in O(logn) time, and thanks to a fancy trick and amortized analysis the entire tree only requires O(n) space.</p>
  <p>The key insight of this approach is to treat one dimension (of the 2D point location problem) as time.  That is, instead of thinking of line segments in the planar graph as being line segments, think of them as the path taken by a moving point over a finite duration.  In this view, one end of the line segment represents where and when the point came into being and the other end represents when the point blinked out of existence forever.  Queries take on a temporal flavor as well, for a given query (1D) point at a given moment (the-other-D) if you happened to have a BST for that moment it would be a simple matter of traversing the tree to see where the query point would fall.</p>
  <p>The challenge then becomes, how can we build a search tree that respects the behavior of time?  To simplify the problem, note that changes to the data structure will only occur at vertcies of the graph.  During intermediate times the points stored in the tree will move, but because the graph is planar they will never cross, the only modification that is required is to store the slope (if you're thinking in 2 spatial dimensions, otherwise think of it as storing the point's speed) of each edge in the tree along side the starting point (and to use that information when searching).  If the queries were guaranteed to come in order we'd be done, we could maintain an ephemeral (ie non-persistent) search tree as we query, adding and removing edges as we proceed chronologically through the list of queries.  Unfortunately this is one assumption that we cannot make, so we'll need to give our search tree some memory by making it persistent.</p>
  <p>Persistent data structures are most easily exemplified by version control systems.  At any given time one person may need to access the current state of the data structure while another needs to roll back to the state from two weeks ago.  They work by maintaining a collection of head pointers with timestamps, where each item pointed to by the head may have been edited at the current time or any previous time.  When an item is added or removed the search path from the current head to the new (or old) node is copied except that the copy reflects the addition or removal, the head of the copied path is associated with the time of the modification and added to the collection of heads.</p>
  <p>In our case we're using a binary search tree that has been modified to be partially persistent, which is to say that only the most recent head can be modified, because it allows for a better space bound.  The space savings is achieved by adding a third pointer and a timestamp to each node in the tree, and when it comes time to modify the decendents of a node the pointer to the new child is stored in the third pointer slot and the timestamp of the modifiation is recorded as well.  If an update would require a fourth pointer the edge is instead copied into a new node that points to the appropriate children nodes and has an empty third pointer.  This limited node copying drops the amortized space cost of a modification to O(1), so the overall space is O(n) for n edges.</p>
  <p>So, with all of that in mind, when you draw a planar graph above and click Toggle Query Mode, here's what happens.  Behind the scenes when you click the button each edge is paired with a start time, and again with a stop time, these 2n events are then sorted chronologically (that is, by horizontal coordinate of the event (point) in the graph) and applied to a partially persistent red black tree.  Then, as you move the mouse across the graph it draws the tree as it existed at the time corresponding to the position of the cursor.  The horizontal parts of the curvy tree intersect with the edges that that branch of the tree represents.</p>
  <p>For each query two binary searches are run: the first is a binary search through time to determine which slab contains the query (cursor).  These slabs represent the insertions and deletions, which is to say, they represent the various search tree heads where a search may begin.  The second binary search is then searching within that version of the tree to locate the highest edge below the query point, which constitutes the answer.</p>
  <h3>Future Work</h3>
  <ul>
  	<li>I spent entirely too much time chasing stupid issues (eg forgetting to enforce general position, coding as if a type checker had my back, etc), and ultimately there wasn't time to actually implement the optimal time bound from the paper.</li>
  	<li>Right now there's no clean way to illustrate the fact that the red black tree is in fact persistent, instead the user has to move the mouse and trust that things aren't being recomputed unnecessarily... or alternatively they could press 'a' and learn to read my debugging format.</li>
  	<li>Right now the red black tree doesn't rebalance after deletions and cursory attempts to add that failed (see above regarding the lack of a type checker).</li>
  </ul>
</body>
</html>